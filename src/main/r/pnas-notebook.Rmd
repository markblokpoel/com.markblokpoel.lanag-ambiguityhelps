---
title: 'Data
  analysis document:<br/>Pragmatic communicators can overcome asymmetry by exploiting ambiguity'
author: Mark Blokpoel, Mark Dingemanse, George Kachergis, Sara BÃ¶gels, Ivan Toni,
  Iris van Rooij and the CABB team
output:
  html_notebook:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
---

# Introduction
This R Notebook describes the data analysis of Blokpoel et al. (2019) *Pragmatic communicators can overcome asymmetry by exploiting ambiguity*. Running the code chunks in order will run all analyses and generates all graphs reported in the main paper. The datasets can be found here [link to Donders Repository or Github](), but you can also run the simulation experiment yourself and use that dataset.

# Packages and settings
Run the following code to install and load the required libraries.

```{r results='hide'}
is_installed <- function(mypkg) is.element(mypkg, installed.packages()[,1])

load_or_install<-function(package_names)
{
  for(package_name in package_names)
  {
    if(!is_installed(package_name))
    {
      install.packages(package_name,repos="http://lib.stat.cmu.edu/R/CRAN")
    }
    library(package_name,character.only=TRUE,quietly=TRUE,verbose=FALSE)
  }
}

suppressWarnings(load_or_install(c("tidyverse",
                  "Hmisc",
                  "reshape2",
                  "extrafont",
                  "plyr",
                  "scales",
                  "RColorBrewer",
                  "grid",
                  "gtable",
                  "plotly",
                  "utils",
                  "data.table",
                  "ggnewscale",
                  "Rmisc")))

loadfonts(quiet = TRUE)

# these are some ggplot settings we use later
tre.12 <- element_text(size = 10, family = "LM Roman 10")
tre.14 <- element_text(size = 12, family = "LM Roman 10")
tre.16 <- element_text(size = 14, family = "LM Roman 10", hjust = 0.5)

ggplot_theme <- theme(panel.background = element_blank(), axis.line = element_line(colour = "black"),
                      panel.grid.major = element_line(colour = "grey"), panel.grid.minor = element_line(colour = "grey"),
                      axis.text = tre.14, axis.title = tre.16, legend.text = tre.12, legend.title = tre.14,
                      plot.title = tre.16)
```

# Main experiment: Pragmatic communicators can overcome asymmetry
Here we run analyses and generate the graphs reported for the main simulation experiment.

## Loading data and pre-processing
We load the data in `.csv` format, remove incomplete cases, round down ambiguity values and remove instances where ambiguity for either agent is 0. Set the variable `dataFolder` to point towards the location where the collection of data files is stored. The script loads all `.csv`-files from that folder. Set the variable `tag` to a string that will be added to all output files.

```{r results='hide'}
# location of the data
dataFolder = "/Users/Mark/Google Drive/Big Question 3/Development/Data/35rounds/uniform2000"
# location and tags for output files
outputFolder = dataFolder
tag = "uniform2000_"

# set variables
outputFolder = paste0(outputFolder, "/figs/")
outputPrefix = paste0(outputFolder, tag)
dir.create(file.path(outputFolder))
csvFiles = list.files(path=dataFolder, pattern="*.csv")

# load the files
data <- do.call("rbind", lapply(csvFiles, function(fn)
  data.frame(Filename=fn, read.csv(paste0(dataFolder, "/" ,fn))
  )))
# remove header data
data <- data[, !(names(data) %in% c("Filename"))]
# round down ambiguity values
data$agent1AmbiguityMean = floor(data$agent1AmbiguityMean)
data$agent2AmbiguityMean = floor(data$agent2AmbiguityMean)
# remove incomplete cases and cases where ambiguity < 1
DFsim <- data[complete.cases(data) & data$agent1AmbiguityMean>0 & data$agent2AmbiguityMean>0, ]
```

This next chunk filters out parts of the parameter space with fewer than $n=15$ samples. With so few samples, we do not get accurate means for these parts of the space. If this filters out too many parts you may need to run the simulation experiment with higher `sample-size`. (For this parameter see simulation software settings in the `application.conf` file.)

```{r results='hide'}
DFsimFilter <- ddply(DFsim,
                     c("agent1AmbiguityMean", "agent2AmbiguityMean", "asymmetry"),
                     summarise,
                     N = length(pairId))
DFsimFilter <- DFsimFilter[DFsimFilter$N >= 15,]

DFsim <- merge(DFsim, DFsimFilter, all = FALSE) # Comment out this line to include outliers.
```
*Table: Random samples from preprocessed summarized data.*
```{r echo=FALSE}
print(DFsim[sample(nrow(DFsim), 10),])
```

### Compute statistics
Many scripts below require summary statistics of the data. We compute these statistics for each condition, `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` $\times$ `asymmetry` $\times$ `agent1order`. Note that both agents in this simulation always have the same order of pragmatic inference (`agent1order` $=$ `agent2order`).

```{r}
suppressWarnings(DFstats <- ddply(DFsim,
                 c("agent1AmbiguityMean", "agent2AmbiguityMean", "asymmetry", "agent1Order"),
                 summarise,
                 N    = length(averageSuccess),
                 mean = mean(averageSuccess),
                 sd   = sd(averageSuccess),
                 se   = sd / sqrt(N),
                 lower_ci = mean - qt(1-(0.05/2), N-1) * se,
                 upper_ci = mean + qt(1-(0.05/2), N-1) * se
))
```
*Table: Random samples from summary statistics.*
```{r echo=FALSE}
print(DFstats[sample(nrow(DFstats), 10),])
```

## Analyses
We compute four analyses: population distribution (Fig. 2 in main paper), main results (Fig. 3), replication and generalization of Frank et al. (2017) (Fig. 4) and evolution of ambiguity (Fig. 5).

### Analysis 1: Theoretical and simulation population distribution
First, we compute the theoretical relationship between the ambiguity of two lexicons $\alpha_1$ and $\alpha_2$ and their asymmetry $\gamma$.

$$
\begin{align}
    \gamma_{\min}&=&1-\frac{1}{|R|}(\min(\alpha_1,\alpha_2)+\min(|R|-\alpha_1,|R|-\alpha_2)\\
    \gamma_{\max}&=&\frac{1}{|R|}(\min(\alpha_1, |R|-\alpha_2)+\min(|R|-\alpha_1,\alpha_2)\\
    \gamma_{\mathrm{mean}}&=&\frac{\alpha_1+\alpha_2}{|R|}-\frac{2\alpha_1\alpha_2}{|R|^2}
\end{align}
$$
```{r}
numberOfReferents = 8
a1s <- 1:numberOfReferents
a2s <- 1:numberOfReferents
DFminMax <- data.frame(matrix(ncol = 5, nrow = 0))
x <- c("ambiguity1", "ambiguity2", "mina", "meana", "maxa")
colnames(DFminMax) <- x

for(a1 in a1s) {
  for(a2 in a2s) {
    maxAsymmetry <- (min(a1,numberOfReferents-a2)+min(a2,numberOfReferents-a1))/numberOfReferents
    meanAsymmetry <- a1/numberOfReferents + a2/numberOfReferents - 2*a1*a2/(numberOfReferents*numberOfReferents)
    minAsymmetry <- 1-(min(a1,a2) + min(numberOfReferents-a1,numberOfReferents-a2))/numberOfReferents
    
    newRow <- data.frame(agent1AmbiguityMean=a1,agent2AmbiguityMean=a2,mina=minAsymmetry,meana=meanAsymmetry,maxa=maxAsymmetry)
    DFminMax <- rbind(DFminMax, newRow)
  }
}

plotTheoreticalDistribution <- function(legendPos = "none", nrCols = 3) {
  ggplot(DFminMax, aes(x = agent1AmbiguityMean, y = meana)) +
  ggplot_theme +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = legendPos) +
  scale_y_continuous(bquote("asymmetry"~gamma), breaks = pretty_breaks(5)) +
  scale_x_continuous(bquote("ambiguity"~alpha[1]), breaks = pretty_breaks(8)) +
  scale_fill_manual("", values = c("theoretical distribution" = "#d95f02")) +
  geom_crossbar(aes(ymin = mina, ymax = maxa, fill = "theoretical distribution")) +
  facet_wrap(. ~ agent2AmbiguityMean, labeller = label_bquote(cols=.(agent2AmbiguityMean)/.(8)), ncol = nrCols)
}
```

*Figure 2: Theoretical population distribution.*
```{r echo = FALSE}
plotTheoreticalDistribution(nrCols = 8)
```

We can analyze how the samples generated in the simulation are distributed over this theoretically possible space. To do this, we summarize for each condition `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` $\times$ `asymmetry` the number of samples and transform them to $\log$-space for readibility.

```{r}
DFcounts <- ddply(DFsim[DFsim$agent1Order==0,],
                  c("agent1AmbiguityMean", "agent2AmbiguityMean", "asymmetry"),
                  summarise,
                  N = log(length(asymmetry)))
DFcounts$N <- DFcounts$N / max(DFcounts$N)

plotMainSimulationDistribution <- function(theoreticalLims = FALSE, legendPos = "none") {
  GGdistribution <- ggplot(DFcounts) +
  ggplot_theme +
  theme(panel.grid.major = element_line(colour="gray"),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        legend.position = legendPos) +
  scale_y_continuous(bquote("asymmetry"~gamma), breaks = pretty_breaks(1)) +
  scale_x_continuous("", breaks = pretty_breaks(1)) +
  scale_fill_manual("", values = c("sample distribution" = "#1b9e77")) +
  scale_color_manual("", values = c("sample distribution" = "#1b9e77")) +
  scale_shape_manual("", values = c("theoretical minimum" = 91, "theoretical mean" = 5, "theoretical maximum" = 93)) +
  geom_rect(aes(xmin = 0, xmax = N, ymin = asymmetry, ymax = asymmetry, fill = "sample distribution", color = "sample distribution")) +
  facet_grid(agent2AmbiguityMean ~ agent1AmbiguityMean,
             labeller=label_bquote(rows=.(agent2AmbiguityMean)/.(8),
                                   cols=.(agent1AmbiguityMean)/.(8))) + 
  coord_flip()


  if(theoreticalLims) {
    GGdistribution <- GGdistribution + 
      geom_point(data = DFminMax, aes(x = 0.2, y = mina, shape = "theoretical minimum"), color = "#d95f02", size = 3.5) +
      geom_point(data = DFminMax, aes(x = 0.2, y = maxa, shape = "theoretical maximum"), color = "#d95f02", size = 3.5) +
      geom_point(data = DFminMax, aes(x = 0.2, y = meana, shape = "theoretical mean"), color = "#d95f02", size = 1.5)
  }
  GGdistribution
}
```

*Figure SI.1: Simulation population distribution.*
```{r echo = FALSE}
plotMainSimulationDistribution(theoreticalLims = TRUE, legendPos = "right")
```

### Analysis 2: Main results
This section describes how Fig. 3 in the paper is generated. This analysis consists of three parts: additional preprocessing and analysis, communicative success and delta asymmetry. The full panel in Fig 3. is generated at the end of this notebook under [Export to PDF](#pdf), which stiches all the subpanels together.

#### Preprocessing and analysis
We compute for each condition `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` how much more asymmetry 1^st^ order agents can incurr, before their communicative success drops below that of the best 0 order agents. We filter zero order agents' and first order agents' data from the general dataframe `simDF`. For each of these two subsets we compute summary statistics, i.e., the mean successrates over pairs of agents in each condition. Here, the conditions are `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` $\times$ `asymmetry`.

```{r}
DFdeltaOrder1 <- DFsim[DFsim$agent1Order==1,
                       c("pairId",
                         "agent1Order",
                         "agent2Order",
                         "agent1AmbiguityMean",
                         "agent2AmbiguityMean",
                         "asymmetry",
                         "averageSuccess")]

DFdeltaOrder1Summary <- ddply(DFdeltaOrder1,
                              c("agent1AmbiguityMean",
                                "agent2AmbiguityMean",
                                "asymmetry"),
                              summarise,
                              meanSuccess = mean(averageSuccess))

DFdeltaOrder0 <- DFsim[DFsim$agent1Order==0,
                       c("pairId",
                         "agent1Order",
                         "agent2Order",
                         "agent1AmbiguityMean",
                         "agent2AmbiguityMean",
                         "asymmetry",
                         "averageSuccess")]

DFdeltaOrder0Summary <- ddply(DFdeltaOrder0,
                              c("agent1AmbiguityMean",
                                "agent2AmbiguityMean",
                                "asymmetry"),
                              summarise,
                              meanSuccess = mean(averageSuccess))
```
*Table: Random samples from zero-order summary statistics*
```{r echo=FALSE}
print(DFdeltaOrder0Summary[sample(nrow(DFdeltaOrder0Summary), 10),])
```
*Table: Random samples from first-order summary statistics*
```{r echo=FALSE}
print(DFdeltaOrder1Summary[sample(nrow(DFdeltaOrder1Summary), 10),])
```

Next, we compute the minimum asymmetry in each `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` condition.
```{r}
DFdeltaMinAsymmetry <- DFdeltaOrder1Summary %>%
                       group_by(agent1AmbiguityMean, agent2AmbiguityMean) %>%
                       top_n(-1, asymmetry)
DFdeltaMinAsymmetry$meanSuccess <- NULL
DFdeltaMinAsymmetry$maxSuccess <- NULL
colnames(DFdeltaMinAsymmetry) <- c("agent1AmbiguityMean", "agent2AmbiguityMean", "minAsymmetry")
```
*Table: Random samples from minimum asymmetry*
```{r echo=FALSE}
print(DFdeltaOrder1Summary[sample(nrow(DFdeltaOrder1Summary), 5),])
```

We then compute the maximum mean communicative success rate for 0 order agents in each `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` condition.
```{r}
DFdeltaMaxSuccessOrder0 <- tapply(DFdeltaOrder0Summary$meanSuccess,
                                  list(DFdeltaOrder0Summary$agent1AmbiguityMean, DFdeltaOrder0Summary$agent2AmbiguityMean),
                                  max)
dimnames(DFdeltaMaxSuccessOrder0) <- list(agent1AmbiguityMean=1:8, agent2AmbiguityMean=1:8)
DFdeltaMaxSuccessOrder0 <- as.data.frame(as.table(DFdeltaMaxSuccessOrder0))
colnames(DFdeltaMaxSuccessOrder0) <- c("agent1AmbiguityMean", "agent2AmbiguityMean", "maxSuccess")
```
*Table: Random samples from minimum asymmetry*
```{r echo=FALSE}
print(DFdeltaMaxSuccessOrder0[sample(nrow(DFdeltaMaxSuccessOrder0), 5),])
```

#### Communicative success
Having computed the mean communicative success rates for each condition, we merge these data frames, compute the intersection by finding the first data point on the above and below of the best 0 order agents' success rate. If the intersection is not exactly on one of these points, we assume a linear relation between those two points and compute the intersection with that function.
```{r}
DFdelta <- merge(x=DFdeltaOrder1Summary, y=DFdeltaMaxSuccessOrder0, by = c("agent1AmbiguityMean", "agent2AmbiguityMean"))

DFdeltaUpperbounds <- DFdelta[DFdelta$meanSuccess>=DFdelta$maxSuccess,]
DFdeltaUpperbounds <- DFdeltaUpperbounds %>% group_by(agent1AmbiguityMean, agent2AmbiguityMean) %>% top_n(1, asymmetry)
DFdeltaLowerbounds <- DFdelta[DFdelta$meanSuccess<=DFdelta$maxSuccess,]
DFdeltaLowerbounds <- DFdeltaLowerbounds %>% group_by(agent1AmbiguityMean, agent2AmbiguityMean) %>% top_n(-1, asymmetry)
DFdeltaLowerbounds$maxSuccess <- NULL

DFdelta <- merge(x=DFdeltaLowerbounds, y=DFdeltaUpperbounds, by = c("agent1AmbiguityMean", "agent2AmbiguityMean"))
DFdelta <- merge(x=DFdelta, y=DFdeltaMinAsymmetry, by = c("agent1AmbiguityMean", "agent2AmbiguityMean"))

DFdelta$a <- ifelse(DFdelta$asymmetry.x == DFdelta$asymmetry.y,
  DFdelta$asymmetry.x - DFdelta$minAsymmetry
,
  (DFdelta$asymmetry.y - DFdelta$asymmetry.x) / 
  (DFdelta$meanSuccess.y - DFdelta$meanSuccess.x) *
  (DFdelta$maxSuccess - DFdelta$meanSuccess.y) +
  DFdelta$asymmetry.y - DFdelta$minAsymmetry
)

plotCommSuccess = function(a1, a2, legendPos = "none") {
  ggplot(DFstats[DFstats$agent1AmbiguityMean==a1 & DFstats$agent2AmbiguityMean==a2 & DFstats$agent1Order<2,]) +
  ggplot_theme +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 14),
        axis.text.x = element_text(),
        axis.text.y = element_text(),
        legend.position = legendPos) +
  scale_y_continuous("", breaks=c(0,0.25,0.5,0.75,1.0), labels = c("0", rep("", 3), "1"), limits = c(0,1)) +
  scale_x_continuous("", breaks = c(0, 0.2, 0.4, 0.6), labels = c("0", "", "", ".6"), limits = c(0,0.6)) +
  geom_line(aes(x = asymmetry, y = mean, color = factor(agent1Order))) +
  geom_point(data = DFdelta[DFdelta$agent1AmbiguityMean==a1 & DFdelta$agent2AmbiguityMean==a2,],
             aes(shape = "intersection", x = a+minAsymmetry, y = maxSuccess), size = 5, show.legend = TRUE) +
  geom_point(data = DFdelta[DFdelta$agent1AmbiguityMean==a1 & DFdelta$agent2AmbiguityMean==a2,],
             aes(shape = "0 order max", x = minAsymmetry, y = maxSuccess), size = 5, show.legend = TRUE) + 
  geom_segment(data = DFdelta[DFdelta$agent1AmbiguityMean==a1 & DFdelta$agent2AmbiguityMean==a2,],
               aes(linetype = "delta", x = minAsymmetry, y = maxSuccess, xend = a+minAsymmetry, yend = maxSuccess)) +
  scale_color_brewer("order of pragmatic inference", palette = "Dark2",
                     guide = guide_legend(override.aes = list(
                       linetype = c("solid", "solid"),
                       shape = c(NA, NA)))) +
  scale_shape_manual("intersection", values = c("0 order max" = 2, "intersection" = 6)) +
  scale_linetype_manual("delta", values = c("delta" = "dashed"), guide = guide_legend(override.aes = list(shape = c(NA))))
}
```

*Figure 3, Panel A: Communicative success and delta asymmetry illustration.*
We can inspect the example graph, but you can change the ambiguity values to inspect different parts of the parameter space.
```{r echo = FALSE}
plotCommSuccess(3, 3, "right")
```

#### Delta asymmetry
This delta statistic is plotted in a heatmap below, for each `agent1AmbiguityMean` $\times$ `agent2AmbiguityMean` condition.
```{r}
plotDeltaAsymmetry = function(legendPos = "none") {
  ggplot(DFdelta, aes(x=factor(agent1AmbiguityMean), y=factor(agent2AmbiguityMean))) +
  ggplot_theme +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 14),
        axis.title.x = element_text(size = 24),
        axis.title.y = element_text(size = 24),
        plot.title = element_text(size = 24),
        legend.position = legendPos) +
  scale_y_discrete(bquote(ambiguity~alpha[1])) +
  scale_x_discrete(bquote(ambiguity~alpha[2])) +
  scale_fill_distiller("delta asymmetry", palette = "BuGn", direction = 1) +
  geom_tile(aes(fill=a))
}
```
*Figure 3, Panel B: Delta asymmetry heatmap.*
```{r echo = FALSE}
plotDeltaAsymmetry("right")
```

### Analysis 3: Replication and generalization
The following analysis shows a replication of the effect reported by Frank et al. (2017) that increasing orders of pragmatic inference has diminishing returns (in terms of communicative success). We compute summary statistics for second order agents, then subtract communicative success of first order agents from second order agents. As a control we also compute the difference in communicative success between first and zero order agents. To replicate the effect, the first analysis should yield values around 0, and the second analysis should yield values greater than 0.
```{r}
DFdeltaOrder2 <- DFsim[DFsim$agent1Order==2,
                       c("pairId",
                         "agent1Order",
                         "agent2Order",
                         "agent1AmbiguityMean",
                         "agent2AmbiguityMean",
                         "asymmetry",
                         "averageSuccess")]


DFreplication21 <- within(merge(DFdeltaOrder2,DFdeltaOrder1, by="pairId"), {
  diffSuccess <- averageSuccess.x - averageSuccess.y
  ambiguity1 <- agent1AmbiguityMean.x
  ambiguity2 <- agent2AmbiguityMean.x
  asymmetry <- asymmetry.x
})[, c("pairId","ambiguity1","ambiguity2","asymmetry" ,"diffSuccess")]

DFreplication10 <- within(merge(DFdeltaOrder1,DFdeltaOrder0, by="pairId"), {
  diffSuccess <- averageSuccess.x - averageSuccess.y
  ambiguity1 <- agent1AmbiguityMean.x
  ambiguity2 <- agent2AmbiguityMean.x
  asymmetry <- asymmetry.x
})[, c("pairId","ambiguity1","ambiguity2","asymmetry","diffSuccess")]

DFreplication21Summary <- ddply(DFreplication21,
                                c("ambiguity1","ambiguity2","asymmetry"),
                                summarise,
                                meanDiffSuccess = mean(diffSuccess),
                                comp = "order 2 - order 1"
                                )

DFreplication10Summary <- ddply(DFreplication10,
                                c("ambiguity1","ambiguity2","asymmetry"),
                                summarise,
                                meanDiffSuccess = mean(diffSuccess),
                                comp = "order 1 - order 0"
                                )

replicationLabeller <- function() {
  repLabels <- vector(mode="character", length=64)
  for(a1 in 1:8) {
    for(a2 in 1:8) {
      repLabels[a1+((a2-1)*8)] <- paste0(a2,"/8:",a1,"/8")
    }
  }
  repLabels
}

plotReplication = function(legendPos = "none") {
 ggplot(DFreplication21Summary, aes(x = asymmetry, y = meanDiffSuccess, color = factor(ambiguity1):factor(ambiguity2))) +
  ggplot_theme +
  theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text = element_text(),
      axis.text.x = element_text(),
      axis.text.y = element_text(),
      legend.position = legendPos) +
  scale_y_continuous("mean difference success", breaks = pretty_breaks(5), limits = c(-0.07,0.5)) +
  scale_x_continuous(bquote(asymmetry~gamma), breaks = pretty_breaks(3)) +
  scale_color_discrete(bquote("ambiguity"~alpha[1]~":"~"ambiguity"~alpha[2]), labels = replicationLabeller()) +
  geom_line(stat = "identity") +
  geom_line(data = DFreplication10Summary, stat = "identity") +
  facet_wrap( ~ comp)
}
```
*Figure 4: Replication and generalization of Frank et al. (2017).*
```{r}
plotReplication()
```

### Analysis 4: Evolution of ambiguity
In this section we generate a sketch of evolutionary trajectories as described in the discussion section. Note that the actual numbers here are meaningless, what matters only is the approximation of the shape of the conjectured evolutionary trajectories.

```{r}
DFevolution <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(DFevolution) <- c("asymmetry", "condition", "ambiguity", "success")


for(x in 0:9/10) {
  # compute asymmetric trajectories
  aa <- x/2
  as <- (2*aa)^2
  newRow <- data.frame(asymmetry="asymmetric",condition="low to medium",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
  aa <- 0.5
  as <- min(x,0.815)
  newRow <- data.frame(asymmetry="asymmetric",condition="medium",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
  aa <- 0.5+((.1+x)/2)
  as <- (2-2*aa)^2
  newRow <- data.frame(asymmetry="asymmetric",condition="high to medium",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
  
  # compute symmetric trajectories
  aa <- 0
  as <- min(x,0.815)
  newRow <- data.frame(asymmetry="symmetric",condition="low",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
  aa <- 0.05+x/2
  as <- (1-2*aa)^2
  newRow <- data.frame(asymmetry="symmetric",condition="medium to low",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
  aa <- 0.1+x
  as <- (1-aa)^2
  newRow <- data.frame(asymmetry="symmetric",condition="high to low",ambiguity=aa,success=as)
  DFevolution <- rbind(DFevolution, newRow)
}

plotEvolution <- function(legendPos = "none") {
  ggplot(DFevolution, aes(x=ambiguity, y=success,color=factor(condition))) +
  ggplot_theme +
  theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text = element_text(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
      legend.position = legendPos) +
  scale_y_continuous("success/fitness") +
  scale_x_continuous(bquote({ambiguity}~alpha/time)) +
  scale_color_brewer("evolutionary trajectory", palette="Set2") +
  geom_line(stat = "identity") +
  facet_wrap( ~ asymmetry)
}
```
*Figure 5: Evolution of ambiguity.*
```{r}
plotEvolution(legendPos= "right")
```

## Export figures to PDF
The following code chunk exports the figures to PDF. The figures in the main paper have been edited and combined using an external PDF editor, hence the 'raw' figures outputted here may differ slightly from the actual figures in the paper.

```{r echo = FALSE, results = 'hide'}
pdf(file = paste0(outputPrefix, "fig2_theoretical_distribution.pdf"), height = 4, width = 8)
plotTheoreticalDistribution(legend = "none", nrCols = 8)
dev.off()

MPlayout <- matrix(c(11,12,3, 4, 5,
                     1, 1, 2, 2, 6,
                     1, 1, 2, 2, 7,
                     13,14,8, 9,10),
                   nrow = 4, byrow = TRUE)

pdf(file = paste0(outputPrefix, "fig3_overview.pdf"), width = 15, height = 12)
multiplot(plotCommSuccess(3,3),
          plotDeltaAsymmetry(),
          plotCommSuccess(4,4), #3
          plotCommSuccess(5,4), #4
          plotCommSuccess(5,5), #5
          plotCommSuccess(4,5), #6
          plotCommSuccess(3,4), #7
          plotCommSuccess(1,1), #8
          plotCommSuccess(2,2), #9
          plotCommSuccess(2,3), #10
          NULL, NULL, NULL, NULL, #11, 12, 13, 14
          cols = 5, layout = MPlayout)
dev.off()

pdf(file = paste0(outputPrefix, "fig3_communicative_success_legend.pdf"))
plotCommSuccess(3,3, legendPos = "right")
dev.off()
 
pdf(file = paste0(outputPrefix, "fig3_delta_asymmetry_legend.pdf"))
plotDeltaAsymmetry(legendPos = "right")
dev.off()

pdf(file = paste0(outputPrefix, "fig4_replication.pdf"), height = 4, width = 8)
plotReplication(legendPos = "none")
dev.off()

pdf(file = paste0(outputPrefix, "fig4_replication_legend.pdf"), height = 9, width = 8)
plotReplication(legendPos = "bottom")
dev.off()

pdf(file = paste0(outputPrefix, "fig5_evolutionary_trajectories.pdf"), height = 5, width = 8)
plotEvolution(legendPos = "bottom")
dev.off()
```

# Supporting Information

## Supporting Experiment A: Random generation

## Supporting Experiment B: Structured generation

```{r}
# plots for random
          # plotPerformance(1,1), #3
          # NULL,#plotPerformance(2,1), #4
          # plotPerformance(2,2), #5
          # NULL,#plotPerformance(3,2), #6
          # NULL,#plotPerformance(4,4), #7
          # NULL,#plotPerformance(4,5), #8
          # NULL,#plotPerformance(3,5), #9

# plots for structured
          # plotPerformance(1,1), #3
          # plotPerformance(2,2), #4
          # plotPerformance(2,3), #5
          # plotPerformance(1,3), #6
          # plotPerformance(3,4), #7
          # plotPerformance(4,5), #8
          # plotPerformance(5,5), #9

# MPlayout <- matrix(c(1, 1, 2, 2, 9,
#                      1, 1, 2, 2, 8,
#                      3, 4, 5, 6, 7),
#                    nrow = 3, byrow = TRUE)
# 
# multiplot(GGdeltaExample + theme(legend.position = "none") + ggtitle(NULL),
#           GGdelta + theme(legend.position = "none") + ggtitle(NULL),
#           plotPerformance(1,1), #3
#           plotPerformance(2,2), #4
#           plotPerformance(2,3), #5
#           plotPerformance(3,5), #6
#           plotPerformance(4,4), #7
#           plotPerformance(4,5), #8
#           plotPerformance(5,5), #9
#           cols = 5, layout = MPlayout)
```






